<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Website Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  	<link rel="stylesheet" type="text/css" href="css\general.css"/>
	<link rel="stylesheet" type="text/css" href="css\sitegraph.css"/>
</head>
<body>
<div id="svg-container"></div>
<script>const json_add= "https://yairmallah.github.io/pgmr/sitemap.json";</script>
<script>
	const width = document.getElementById("svg-container").offsetWidth;
	const height = document.getElementById("svg-container").offsetHeight;
	console.log(width, height);
	const gridSize = 100;
	const offs = 10;
	const bounds = {
		html: { xMin: width/3 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height/2 - offs  },
		css: { xMin: 0 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height - offs  },
		js: { xMin: 0 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height - offs  },
		img: { xMin: 0 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height - offs  },
		txt: { xMin: 0 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height - offs  },
		other: { xMin: 0 + offs, xMax: width - offs, 
				yMin: 0 + offs, yMax: height - offs  }
	};
	const areas = {
		html: { x: width / 3, y: height / 2 },
		css: { x: width / 6, y: height / 3 },
		js: { x: (5 * width) / 6, y: height / 3 },
		img: { x: width / 4, y: (2 * height) / 3 },
		txt: { x: (3 * width) / 4, y: (2 * height) / 3 }
	};

	function getFileType(filename) {
		if (filename.endsWith(".html")) return "html";
		if (filename.endsWith(".css")) return "css";
		if (filename.endsWith(".js")) return "js";
		if (filename.match(/\.(jpg|png|gif|svg|jpeg|webp)$/)) return "img";
		if (filename.endsWith(".txt")) return "txt";
		return "other";
	}

	d3.json(json_add).then(graph => {
		const svg = d3.select("#svg-container")
			.append("svg")
			.attr("width", width)
			.attr("height", height);

		const simulation = d3.forceSimulation(graph.nodes)
			.force("link", d3.forceLink(graph.links).id(d => d.id).strength(0.2).distance(100))
			.force("charge", d3.forceManyBody().strength(-200))
			//.force("bounds", forceBounds(bounds))
			/*.force("x", d3.forceX(d => areas[getFileType(d.id)]?.x || width / 2).strength(0.2))
			.force("y", d3.forceY(d => areas[getFileType(d.id)]?.y || height / 2).strength(0.2))*/
			.force("grid", forceGrid(gridSize, 0.5)) // Grid force with weak strength
			.alphaDecay(0.01); // Make the simulation continue running slowly

		const link = svg.selectAll("path")
			.data(graph.links)
			.enter().append("path")
			.attr("class", d => "pathS-"+getFileType(d.source.id) +" pathE-"+getFileType(d.target.id));


		const node = svg.selectAll("circle")
			.data(graph.nodes)
			.enter().append("circle")
			.attr("class", d => getFileType(d.id))
			.on("mouseover", sendWave)
			.on("click", (event, d) => window.open(d.url, "_blank"));

		const labels = svg.selectAll("text")
			.data(graph.nodes)
			.enter().append("text")
			.attr("dy", -15)
			.attr("text-anchor", "middle")
			.text(d => d.id);

		simulation.on("tick", () => {
			node
				.attr("transform", d => 'translate('+Math.max(bounds[getFileType(d.id)].xMin,Math.min(bounds[getFileType(d.id)].xMax, d.x))+','+
													Math.max(bounds[getFileType(d.id)].yMin,Math.min(bounds[getFileType(d.id)].yMax, d.y))+')')
													
				/*.attr("cx", d => d.x)
				.attr("cy", d => d.y);*/
				/*d.x = Math.max(bounds[getFileType(d.id)].xMin, Math.min(bounds[getFileType(d.id)].xMax, d.x));
				d.y = Math.max(bounds[getFileType(d.id)].yMin, Math.min(bounds[getFileType(d.id)].yMax, d.y));*/
		
			link.each(function(d) {
				const path = segmentedPath(d.source, d.target, gridSize);
				const line = d3.select(this);
				const dAttr = `M ${path[0].x},${path[0].y} ` + path.map(p => `L ${p.x},${p.y}`).join(" ");
				line.attr("d", dAttr);
			});

			labels
				.attr("x", d => d.x)
				.attr("y", d => d.y);
		});
		

		function sendWave(event, d) {
			const visited = new Set();
			const speed = 1000;// !!Constant speed per segment

			function propagate(source) {
				visited.add(source.id);
				graph.links.forEach(link => {
					if (link.source.id === source.id && !visited.has(link.target.id)) {
						const path = segmentedPath(link.source, link.target, gridSize);
						const dot = svg.append("circle")
							.attr("class", "wave w"+source.class)
							.attr("cx", path[0].x)
							.attr("cy", path[0].y);

						function travel(index) {
							if (index >= path.length) {
								dot.remove();
								propagate(link.target);
								return;
							}

							dot.transition()
								.duration(speed)
								.attr("cx", path[index].x)
								.attr("cy", path[index].y)
								.on("end", () => travel(index + 1));
						}

						travel(1); // Start from second point
					}
				});
			}
			propagate(d);
		}
		// 45 deg gen
		function segmentedPath(source, target, size) {
			const points = [{ x: source.x, y: source.y }];
			let [x, y] = [source.x, source.y];
			const targetX = target.x ;
			const targetY = target.y ;
			digLen = Math.min(Math.abs(targetX - x),Math.abs(targetY - y));
			nextX = x + (Math.sign(targetX - x) * digLen);
			nextY = y + (Math.sign(targetY - y) * digLen);
			points.push({ x: nextX, y: nextY });
			[x, y] = [nextX, nextY];
			points.push({ x: targetX, y: targetY });
			return points;
		}

		function forceGrid(size, strength) {
			return (alpha) => {
				graph.nodes.forEach(d => {
				const gridX = Math.round(d.x / size) * size;
				const gridY = Math.round(d.y / size) * size;
				d.vx += (gridX - d.x) * strength * alpha;
				d.vy += (gridY - d.y) * strength * alpha;
				});
			};
		}
		function forceBounds(bounds) {
			return function(alpha) {
				for (const node of simulation.nodes()) {
					console.log(node);
					node.x = Math.max(node.bounds.xMin, Math.min(node.bounds.xMax, node.x));
					node.y = Math.max(node.bounds.yMin, Math.min(node.bounds.yMax, node.y));
				}
			};
		}
	});
</script>

</body>
</html>

