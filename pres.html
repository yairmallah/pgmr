<!DOCTYPE html>
<html lang="he">
    <head>
        <meta charset="UTF-8">
		<link rel="prefetch" href="references.html">
		<link rel="prefetch" href="index.html">
		<link rel="prefetch" href="video.html">
		<link rel="prefetch" href="video.html?vid=1">
		<link rel="prefetch" href="imgs/הגשה.mp4" as="video">
		<link rel="prefetch" href="imgs/סימולציה.mp4" as="video">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>פרזנטציה</title>
		<script id="main-dict">
			// index => 0=addres, 1=tumbnail
			const phase_data = {
				0: ["references.html", {true:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph1.gif", false:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph1I.gif"}],
				1: ["index.html", {true:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph2.gif", false:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph2I.gif"}],
				2: ["video.html", {true:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph3.gif", false:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph3I.gif"}],
				3: ["video.html?vid=1", {true:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph4.gif", false:"https://yairmallah.github.io/pgmr/imgs/thumbnails/ph4I.gif"}],
			};
			// time table
			const timeTable = {
				0 : {
					3: () => phase1_change_ref(phase1_ref_list[0]),
					5: ()=> phase1_zoom('71.9751% 83.1865%'),
					10: () => phase1_change_ref(phase1_ref_list[1]),
					12: ()=> phase1_zoom(),
					17: () => phase1_change_ref(phase1_ref_list[2]),
					19: ()=> phase1_zoom('47.5768% 43.413%'),
					24: () => phase1_change_ref(phase1_ref_list[3]),
					26: ()=> phase1_zoom('39.278% 51.6362%'),
					31: () => phase1_change_ref(phase1_ref_list[4]),
					33: ()=> phase1_zoom('39.278% 76.8093%'),
					38: () => phase1_change_ref(phase1_ref_list[5]),
					41: ()=> phase1_zoom('43.9253% 42.2383%'),
					46: () => phase1_change_ref(phase1_ref_list[6]),
					48: ()=> phase1_zoom('54.2158% 50.965%'),
					53: () => phase1_change_ref(phase1_ref_list[7]),
					55: ()=> phase1_zoom('53.3387% 43.5581%'),
					60: () => update_phase()
				}, 
				1 : {
					/*0: ()=> phase2_position_legend(),*/
					7: () => phase2_random_wave(),
					19: () => phase2_random_wave(),
					31: () => phase2_random_wave(),
					43: () => phase2_random_wave(),
					51: () => update_phase()
				},
				2 : {
					0: () => phase34_paly_vid()/*,
					56: () => update_phase()*/
				},
				3 : {
					0: () => phase34_paly_vid()/*,
					105: () => update_phase()*/
				}
			};
			
		</script>
		<script id="overide">
			function catch_overide(e){
				if (e.key == 'o') {
					overide_time_mec = !overide_time_mec;
					console.log("overide mechanism structure is ", overide_time_mec);
				}
				if (e.key == 's') {
					overide_stop_button = !overide_stop_button;
					console.log("time lock is ", overide_stop_button);
				}
			}
		</script>
		<script id="iframe-halper">
			function getMain(){
				return document.getElementById("main");
			}
			function getDocumentScripture(iframe){
				iframeDoc = null;
				try {
					iframeDoc = iframe.contentWindow;
				} catch (error) {
					console.error(error);
					console.error(iframe);
					iframeDoc = null;
				}
				return iframeDoc;
			}
			function getDocumentSelector(iframe){
				iframeDoc = null;
				try {
					iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
				} catch (error) {
					console.error(error);
					console.error(iframe);
					iframeDoc = null;
				}
				return iframeDoc;
			}
			function waitForToggleMode(iframe, callback, timeout = 2000) {
				const start = Date.now();

				(function check() {
					const fn = iframe.contentWindow?.toggleMode;
					if (typeof fn === 'function') {
						callback(fn); // success!
					} else if (Date.now() - start < timeout) {
						setTimeout(check, 50); // keep checking
					} else {
						console.warn("toggleMode not available in iframe after timeout");
					}
				})();
			}
			function waitForToggleModeDict(iframe, property, callback, timeout = 2000) {
				const start = Date.now();
				(function check() {
					try{
						const fn = iframe.contentWindow?.darkValues[true][property];
						if (fn != null) {
							callback(fn); // success!
						} else if (Date.now() - start < timeout) {
							setTimeout(check, 50); // keep checking
						} else {
							console.warn("toggleMode not available in iframe after timeout");
						}
					}
					catch (e){
						if (Date.now() - start < timeout) {
							setTimeout(check, 50); // keep checking
						} else {
							console.warn("toggleMode not available in iframe after timeout");
						}
					}
				})();
			}
			function waitForObj(iframe, objID, callback, timeout = 2000) {
				const start = Date.now();
				(function check() {
					const fn = iframeDoc = iframe.contentDocument.getElementById(objID) || iframe.contentWindow.document.getElementById(objID);
					if ( fn != null) {
						callback(fn); // success!
					} else if (Date.now() - start < timeout) {
						setTimeout(check, 50); // keep checking
					} else {
						console.warn("toggleMode not available in iframe after timeout");
					}
				})();
			}
			function waitForFunc(iframe, funcName, callback, timeout = 2000) {
				const start = Date.now();

				(function check() {
					try {
						const fn = iframe.contentWindow?.[funcName];
						if (typeof fn === 'function') {
							callback(fn); // success!
						} else if (Date.now() - start < timeout) {
							setTimeout(check, 50); // keep checking
						} else {
							console.warn(`${funcName} not available in iframe after timeout`);
						}
					} catch (err) {
						console.error(err);
					}
				})();
			}
			function waitForAtt(iframe, attName, callback, timeout = 2000) {
				const start = Date.now();

				(function check() {
					try {
						const fn = iframe.contentWindow?.[attName];
						if ( fn != null) {
							callback(fn); // success!
						} else if (Date.now() - start < timeout) {
							setTimeout(check, 50); // keep checking
						} else {
							console.warn(`${funcName} not available in iframe after timeout`);
						}
					} catch (err) {
						console.error(err);
					}
				})();
			}
			function waitForClass(iframe, clsID, callback, timeout = 2000) {
				const start = Date.now();
				(function check() {
					const fn = iframeDoc = iframe.contentDocument.getElementsByClassName(clsID) || iframe.contentWindow.document.getElementsByClassName(clsID);
					if ( fn.length != 0) {
						callback(fn); // success!
					} else if (Date.now() - start < timeout) {
						setTimeout(check, 50); // keep checking
					} else {
						console.warn("toggleMode not available in iframe after timeout");
					}
				})();
			}
		</script>
		<script id="pop-navigators">
			function popNav(iframe){
				try{
					iframe = iframe.contentDocument || iframe.contentWindow.document;
					requestAnimationFrame(() => {
						const naver = iframe.getElementById('navContainer');
						if (naver) {naver.remove();}
					});
					
				} catch (error) {
					console.error(error);
					console.log(iframe);
				}
			}
			
			function popNavs(){
				let iframes = document.querySelectorAll("iframe");
				iframes.forEach(i => {popNav(i)});
			}
			
			function attachActivityListeners(doc, act) {
				['mousemove', 'keydown', 'scroll', 'touchstart'].forEach(evt => {
					doc.addEventListener(evt, act, true); // useCapture=true to ensure you catch events early
				});
			}
			
			function attachActivityToIframes(act) {
				attachActivityListeners(document, act);
				document.querySelectorAll('iframe').forEach(iframe => {
					try {
						// Wait for iframe to be ready
						const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
						if (iframeDoc.readyState === 'complete' || iframeDoc.readyState === 'interactive') {
							attachActivityListeners(iframeDoc, act);
						} else {
							iframe.addEventListener('load', () => {
								try {
									const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
									attachActivityListeners(iframeDoc, act);
								} catch (e) {
									// Ignore cross-origin
									console.log(e);
								}
							});
						}
					} catch (e) {
						console.log(e);
						// Cross-origin iframe
					}
				});
			}
		</script>
		<script id="motion-text-helper">
			var timeToWord = 150;
			function textAppearWordByWord(textElement){
				let id = textElement.id.split("-")[1];
				let original = textElement.innerHTML;
				
				let words = original.split(" ");
				textElement.innerHTML = ""; // Clear original text
				const timeouts = [];
				const spans = [];
				
				textElement.classList.toggle("hidden", false);
				words.forEach((word, index) => {
					const span = document.createElement("span");
					span.textContent = word + " ";
					span.style.opacity = 0;
					span.style.transition = "opacity 1s ease";
					textElement.appendChild(span);
					spans.push(span);

					const t = setTimeout(() => {
						span.style.opacity = 1;
						if (window.current_phase != id){
							textElement._animation.cancel();
						}
					}, index * timeToWord);
					timeouts.push(t);
					
				});		

				const totalDuration = (words.length + 1) * timeToWord;
				const resetTimeout = setTimeout(() => {
					textElement.innerHTML = original; // Restore original HTML
				}, totalDuration);
				timeouts.push(resetTimeout);
				textElement._animation = {
					timeouts,
					spans,
					finish: () => {
						timeouts.forEach(clearTimeout);
						spans.forEach(span => span.style.opacity = 1); // Instantly show all words
					},
					cancel: () => {
						timeouts.forEach(clearTimeout);
						textElement.innerHTML = original;
					}
				};
			}
			function stepShowSetup(stepP){
				const parStepInd = parseInt(stepP.id.split("-")[1]);
				if (parStepInd < window.current_phase){
					stepP.classList.toggle("hidden", false);
				}
				else {
					stepP.classList.toggle("hidden", true);
				}
			}
			function stepShowActual(stepP){
				const parStepInd = parseInt(stepP.id.split("-")[1]);
				if (parStepInd < window.current_phase){
					stepP.classList.toggle("hidden", false);
				}
				else if (parStepInd > window.current_phase){
					stepP.classList.toggle("hidden", true);
				} else {textAppearWordByWord(stepP); }
			}			
		</script>
		<script id="contemporarry-funcs">
			phase1_ref_list = [
				"https://yairmallah.github.io/pgmr/imgs/ref/0p-palace of minos.jpg", // 0 minos palace
				//"https://yairmallah.github.io/pgmr/imgs/ref/1p-pantheon.png", // 1 pantheon
				"https://yairmallah.github.io/pgmr/imgs/ref/2p-baths of caracalla.jpg", // 1 good
				"https://yairmallah.github.io/pgmr/imgs/ref/4p-bauhaus.png", // 2 bauhaus
				"https://yairmallah.github.io/pgmr/imgs/ref/5i-freeway park.jpg", // 3 halperin
				"https://yairmallah.github.io/pgmr/imgs/ref/5i-visitors center vijversburg park.jpg", // 4 road
				"https://yairmallah.github.io/pgmr/imgs/ref/5p-lloyds building.jpg", // 5 loydes B
				"https://yairmallah.github.io/pgmr/imgs/ref/5p-house monsaraz.jpg", // 6 mateas
				"https://yairmallah.github.io/pgmr/imgs/ref/5p-national parliament of bangladesh.png" // 7 kahn
			];
			function phase1_change_ref(img_url){
				/*
				important!!
				updateMainRef needs only ref, ref["url"]=> image url so sent only wrapper of {"url":"https://yairmallah.github.io/pgmr/imgs/ref/EXAMPLE.png"}
				might cause some problem but who know :>
				
				v2 - ref key should be file name so this version will be able to accsses ref dict
				*/
				let main_iframe = getMain();
				waitForFunc(main_iframe, 'updateMainRef', () => {
					waitForObj(main_iframe, "large-scheme", () => {
						torah = getDocumentScripture(main_iframe);
						
						let successfull = false;
						waitForAtt(main_iframe, "refJson", () => {
							let refKey = img_url.split("/");
							refKey = refKey[refKey.length-1];
							navi = torah.refJson[refKey];
							torah.updateMainRef(navi);
							successfull = true;
						});
						if (!successfull) torah.updateMainRef({"url":img_url});
					});
				});
				
				
			}
			function phase1_zoom(zoom_loc='center center'){
				let main_iframe = getMain();
				waitForFunc(main_iframe, 'zoomSlow', () => {
					// no need to wait cause its always after updateMainRef
					/*waitForObj(main_iframe, "large-scheme", () => {*/
					console.log(zoom_loc);
					torah = getDocumentScripture(main_iframe);
					torah.zoomSlow(3, -1, zoom_loc, 50);
					//});
				});
			}
			function phase2_random_wave(){
				let main_iframe = getMain();
				waitForFunc(main_iframe, 'randomWave', () => {
					torah = getDocumentScripture(main_iframe);
					torah.randomWave();
				});
			}
			function phase2_position_legend(){
				let legend_par ='<div class="legend" id="sym">'+
					'<table class="legend-table">'+
						'<tbody><tr>'+
							'<td>משתמש</td>'+
							'<td><div class="legendColor" style="background-color: hsl(224, 20%, 60%);"></div></td>'+
						'</tr>'+
						'<tr>'+
							'<td>בקרה</td>'+
							'<td><div class="legendColor" style="background-color: hsl(5, 20%, 25%);"></div></td>'+
						'</tr>'+
						'<tr>'+
							'<td>לוגי</td>'+
							'<td><div class="legendColor" style="background-color: hsl(0, 75%, 50%);"></div></td>'+
						'</tr>'+
						'<tr>'+
							'<td>שרת</td>'+
							'<td><div class="legendColor" style="background-color: hsl(224, 80%, 29%);"></div></td>'+
						'</tr>'+
					'</tbody></table>'+
				'</div>'
				
				let cont = document.createElement("div");
				cont.id = "ph3-legend";
				cont.innerHTML = "<div></div><div></div>" + legend_par;
				document.querySelector("body").appendChild(cont);
				window.temp_legend2 = cont;
			}
			function phase3_position_legend(){
				let main_iframe = getMain();
				waitForFunc(main_iframe, 'pop_legend', () => {
					torah = getDocumentScripture(main_iframe);
					let legend_par = torah.pop_legend();
					let cont = document.createElement("div");
					cont.id = "ph3-legend";
					cont.innerHTML = "<div></div><div></div>" + legend_par;
					document.querySelector("body").appendChild(cont);
					window.temp_legend3 = cont;
				});
			}
			function phase34_bind_flip(){
				let main_iframe = getMain();
				waitForObj(main_iframe, "myVideo", () => {
					selector = getDocumentSelector(main_iframe);
					selector.getElementById('myVideo').addEventListener('ended', function () {
						if (overide_time_mec && window.current_phase == 3){
							const img = document.createElement("div");
							img.id = "overkill-last-img";							
							document.body.appendChild(img);
							setTimeout(() => {
								img.addEventListener('click', ()=> {
									window.current_phase = 0;
									startBlackoutAndReload();
								});
								img.style.opacity = 1;
							}, 50);
							
							return;
						}
						if (!userIsActive) update_phase();
						else {
							(function check() {
								if (!userIsActive) update_phase();
								else setTimeout(check, 5000); // keep checking
							})();
						}
					});
				});
			}
			function phase34_paly_vid(){
				let main_iframe = getMain();
				setTimeout(() => {
				waitForFunc(main_iframe, 'playVid', () => {
					waitForObj(main_iframe, "myVideo", () => {
						torah = getDocumentScripture(main_iframe);
						torah.playVid();
						phase34_bind_flip();
					});
				});}, 500);
			}
			function indexPageAdaptor(iframe, transform='transform: scale(0.66);transform-origin: top left;height: 150%;'){
				//const iDoc = getDocumentSelector(iframe);
				waitForObj(iframe, "display-layout", () => {getDocumentSelector(iframe).getElementById("display-layout").remove();});
				waitForClass(iframe, 'symBg', () => {
					layouts = getDocumentSelector(iframe).getElementsByClassName('symBg');
					for (let i = 0; i<layouts.length; i++){layouts[i].classList.toggle("hidden", false);}
				});
				waitForToggleModeDict(iframe, "--bgImg", () => {
					let iScript = getDocumentScripture(iframe)
					iScript.darkValues[true]["--bgImg"] = "none";
					iScript.toggleMode((sessionStorage.getItem("isDark") || true));
				});
				iframe.style = transform;
			}
			
		</script>
		<script id="page-reload">
			//startBlackoutAndReload();


			function startBlackoutAndReload() {
				const phase = window.current_phase;
				sessionStorage.setItem("phase", phase);
				const overlay = document.getElementById("phase-title-container");
				overlay.style.background = "var(--bgBody)";
				overlay.style.opacity = 0;
				overlay.classList.toggle("hidden", false);
				overlay.style.opacity = 1;
				document.getElementById("phase-title-trans").innerHTML = "";
				

				// Wait for the fade-in to complete before reload
				setTimeout(() => {
					location.reload(); // triggers reload with black overlay on top
				}, 2000); // match the fade-in duration
			}

			// When page loads, keep overlay visible and fade it out
			window.addEventListener("load", () => {
				update_phase(sessionStorage.getItem("phase") || 0)
				sessionStorage.setItem("phase", 0);
			});

		</script>
		<script id="big-time-functions">
			let fadeOutTimeout = null;
			let hideTimeout = null;
			let mainIframeUpdateTimeout = null;
			let stepShowTimeout = null;
			var backStagePartOnePassed = false;
			var backStagePartTwoPassed = false;
			var phase_passed = 0;
			const userActivityEvents = ['mousemove', 'keydown', 'scroll', 'touchstart'];
							
			function backStageP1(){
				// responsible for iframe load, run after 1s (when stagrs are pulled down)
				if (backStagePartOnePassed) return;
				
				let main_iframe = document.getElementById("main");
				
				for (let i = 0; i < 4; i ++){
					let stepName = 'st-'+i;
					stepShowSetup(document.getElementById(stepName));
				}
				main_iframe.src = phase_data[current_phase][0];
				if (current_phase == 1) indexPageAdaptor(main_iframe);
				else {main_iframe.style = "";}
				popNav(main_iframe);
				
				backStagePartOnePassed = true;
				setTimeout( () =>{attachActivityToIframes(resetActivity);}, 1000);
			}
			function backStageP2(){
				// responsible for text load, run after 3.5s (when stagrs are being pulled up)
				let main_texts = document.getElementById("main-texts-wrapper");
				
				if (backStagePartTwoPassed) return;
				if (current_phase == 1) phase2_position_legend();
				if (current_phase == 2) phase3_position_legend();
				for (let i = 0; i < 4; i ++){
					let stepName = 'st-'+i;
					stepShowActual(document.getElementById(stepName));
				}
				main_texts.scrollTo({
					top: main_texts.scrollHeight,
					behavior: 'smooth'
				});
				backStagePartTwoPassed = true;
				if (timeTable[window.current_phase][0]) {
					timeTable[window.current_phase][0]();
				}
			}
			
			function phase_transition(t=4){
				const titleCont = document.getElementById('phase-title-container');
				if (titleCont.style.opacity == 1) {
					titleCont.style.transition = "background 1s ease";
					titleCont.style.background = "";
					setTimeout(() => {titleCont.style.transition = "";}, 1000);
				};
				titleCont.classList.remove('hidden');
				
				const titleEl = document.getElementById('phase-title-trans');
				titleEl.innerHTML = "";
				// Trigger fade in
				requestAnimationFrame(() => {
					titleCont.style.opacity = 1;
				});
				
				setTimeout(() => {
					let titleI = "I".repeat(window.current_phase + 1);
					if (window.current_phase == 3) titleI = "IV";
					titleEl.innerHTML = "<div id='temp-title-wrapper' style='opacity: 0; transition: opacity 1.5s ease;'>" + titleI + " <br/> " +document.getElementById('txt-btn-'+window.current_phase).innerHTML + "</div>";
					setTimeout(() => {
						document.getElementById('temp-title-wrapper').style.opacity = 1;
					}, 50);
				}, 2000);
				
				
				const stopTransition = () => {
					resetActivity();
					const clone = titleCont.cloneNode(true); // true = deep clone
					try {
						titleCont.parentNode.replaceChild(clone, titleCont);
						userActivityEvents.forEach(evt => {
							titleCont.removeEventListener(evt, stopTransition);
						});
					}catch (e) {}
					backStageP1();
					clearTimeout(mainIframeUpdateTimeout);
					backStageP2();
					clearTimeout(stepShowTimeout);
					clearTimeout(fadeOutTimeout);
					clearTimeout(hideTimeout);
					clone.classList.toggle('hidden', true);
					clone.style.opacity = 0;
				};
				if (!overide_time_mec){
					setTimeout(() => {
						userActivityEvents.forEach(evt => {
							titleCont.addEventListener(evt, stopTransition);
						});
					}, 2000);
				}


				fadeOutTimeout = setTimeout(() => {
					titleCont.style.opacity = 0; // Start fade out
					// After 1 more second, hide it completely
					hideTimeout = setTimeout(() => {
						titleCont.classList.add('hidden', true);
						window.inactiveSeconds = 0;
						stopTransition;
					}, 2000);
				}, (t-2)*1000);			
			}
			function stepShow(stepP){
				const parStepInd = parseInt(stepP.id.split("-")[1]);
				if (parStepInd < window.current_phase){
					stepP.classList.toggle("hidden", false);
				}
				else if (parStepInd > window.current_phase){
					stepP.classList.toggle("hidden", true);
				} else {textAppearWordByWord(stepP); }
			}
			
			function update_phase(phs=-1){
				// constant stabilitation
				phase_passed += 1;
				backStagePartOnePassed = false;
				backStagePartTwoPassed = false;
				window.inactiveSeconds = -4;
				document.getElementById(("st-" + window.current_phase)).classList.toggle("chosen", false);
				document.getElementById(("ph-" + window.current_phase)).classList.toggle("chosen", false);
				if (phs == -1){current_phase += 1;}
				else {current_phase = phs;}
				current_phase %= 4;
				window.current_phase = current_phase;
				
				if (phase_passed >= 13) {
					startBlackoutAndReload();
					return;
				}
				
				let trans_time = 6
				
				// texts beahavior
				document.getElementById(("st-" + current_phase)).classList.toggle("chosen", true);
				document.getElementById(("ph-" + current_phase)).classList.toggle("chosen", true);
				if (window.temp_legend2) window.temp_legend2.remove();
				if (window.temp_legend3) window.temp_legend3.remove();
				phase_transition(trans_time);
				
				mainIframeUpdateTimeout = setTimeout(() => {
					backStageP1();
				}, 2000);
				stepShowTimeout = setTimeout(() => {
					backStageP2();
				}, trans_time * 1000 - 500);
			}
		</script>
		<link rel="stylesheet" type="text/css" href="css\general.css"/>
		<link rel="stylesheet" type="text/css" href="css\pres.css"/>
        <script type="module">
			import { darkValues/*, toggleMode*/ } from "https://yairmallah.github.io/pgmr/displayMode.js";
			Object.assign(darkValues[true],{
				"--invBG":darkValues[false]["--bgBody"],
				"--invTXT":darkValues[false]["--textColor"],
				"--btnImgFilter":"none"
			});
			Object.assign(darkValues[false],{
				"--invBG":darkValues[true]["--bgBody"],
				"--invTXT":darkValues[true]["--textColor"],
				"--btnImgFilter":"hue-rotate(180deg) invert(1)"
			});
			/*for (const i in phase_data){
				darkValues[true]['--thumbnailPh' + i.toString()]= 'url("' + phase_data[i][1][true] + '")';
				darkValues[false]['--thumbnailPh' + i.toString()]= 'url("' + phase_data[i][1][false] + '")';
			}*/
			window.darkValues = darkValues;
			const toggleMode=(isDark)=>{
				Object.keys(darkValues[isDark]).forEach(varMode => {
					const root = document.documentElement;
					root.style.setProperty(varMode, darkValues[isDark][varMode]);
				});
				let iframes = document.querySelectorAll("iframe");
				iframes.forEach(i => {
					let iScript = getDocumentScripture(i);
					waitForToggleMode(i, () => {iScript.toggleMode(isDark);});
				});
				sessionStorage.setItem("isDark", isDark);
			};
			window.toggleMode = toggleMode;
			// rebind click event to the display mode buttons for path regenerationg
			requestAnimationFrame(() => {
				try {
					document.getElementById("toggle-light").addEventListener("click", () => {toggleMode(false)});
					document.getElementById("toggle-dark").addEventListener("click", () => {toggleMode(true)});
				}catch (e) {
					console.log("no display mode button error ", e);
				}
				let isDark = sessionStorage.getItem("isDark") || true;
				toggleMode(isDark);
			});
		</script>
        <script type="module" src="https://yairmallah.github.io/pgmr/navLogic.js"></script>	
    </head>
    <body>
		<div id="phase-title-container" class="", style="background: var(--bgBody); opacity:1;">
			<div style="pointer-events: none;">
			</div>
			<div id="phase-title-trans" class="covers"></div>
			<div class="covers">
			</div>
		</div>
		<div id="thumbnails-container">
			<div id="buttons-container">
				<button class="phase-button" id="ph-0" onclick="update_phase(0)">
					<div id="phd-0" class="phase-button-image"></div>
					<p class="btn-txt" id="txt-btn-0">מפידיאס עד לואי קאהן</p>
				</button>
				<button class="phase-button" id="ph-1" onclick="update_phase(1)">
					<div id="phd-1" class="phase-button-image"></div>
					<p class="btn-txt" id="txt-btn-1">ארכיטקטורה בעידן המכונה השלישי</p>
				</button>
				<button class="phase-button" id="ph-2" onclick="update_phase(2)">
					<div id="phd-2" class="phase-button-image"></div>
					<p class="btn-txt" id="txt-btn-2">ירושלים כמודל פרוגרמתי</p>
				</button>
				<button class="phase-button" id="ph-3" onclick="update_phase(3)">
					<div id="phd-3" class="phase-button-image"></div>
					<p class="btn-txt" id="txt-btn-3">מימוש מודל על גבעת רם</p>
				</button>
			</div>
		</div>
			
			<iframe id="main" src=""></iframe>
			<script id="phases-starter">
				var current_phase = sessionStorage.getItem("phase") || 0;
				window.current_phase = current_phase;
				var inactiveSeconds = 0;
				window.inactiveSeconds = inactiveSeconds;
				var userIsActive = true;
				var lastActivityTime = Date.now();
				var activity_threshold = 4;
				var overide_time_mec = false;
				var overide_stop_button = false;

				// Track activity
				function resetActivity() {
					userIsActive = true;
					lastActivityTime = Date.now();
					document.getElementById("navContainer").classList.toggle("hidden", false);
					document.getElementsByTagName("body")[0].classList.toggle("no-mouse", false);
					document.querySelectorAll("iframe").forEach(ifrm => {ifrm.classList.toggle("no-mouse", false)});
					inactiveSeconds = Math.max(inactiveSeconds, 0);
					window.inactiveSeconds = inactiveSeconds
					// bad implementation but good idea: active geen light
					//document.getElementById('status').textContent = "Active";
				}
				function stopActivity(){
					userIsActive = false;
					document.getElementById("navContainer").classList.toggle("hidden", true);
					document.getElementsByTagName("body")[0].classList.toggle("no-mouse", true);
					document.querySelectorAll("iframe").forEach(ifrm => {ifrm.classList.toggle("no-mouse", true)});
				}

				

				// Main loop
				setInterval(() => {
					// run every second
					const now = Date.now();
					const elapsed = Math.floor((now - lastActivityTime) / 1000);

					if ((!overide_time_mec) && elapsed > activity_threshold) {
						if (userIsActive) stopActivity();
						inactiveSeconds += 1;
						console.log(inactiveSeconds);

						// Check if a function is scheduled for this time
						if (timeTable[window.current_phase][inactiveSeconds]) {
							timeTable[window.current_phase][inactiveSeconds]();
						}
					}
					if (overide_time_mec && (!overide_stop_button)){
						if (userIsActive) stopActivity();
						inactiveSeconds += 1;
						console.log(inactiveSeconds);

						// Check if a function is scheduled for this time
						if (timeTable[window.current_phase][inactiveSeconds]) {
							timeTable[window.current_phase][inactiveSeconds]();
						}
					}
				}, 1000);
		
				requestAnimationFrame(() => {
					//update_phase(0);
					attachActivityToIframes(resetActivity);
					window.addEventListener("keydown", (e) => {catch_overide(e)});
				});
			</script>
	<div id="main-texts-wrapper">
		<div id="main-texts">
					<p class="main-text hidden" id="st-0">
						במסגרת צורת החשיבה הקלאסית, ארכיטקטורה הייתה נתונה תמיד במתח חומר-חלל. עם השכלול הטכנולוגי של ראשית המאה הקודמת, המאופיין במהירות, נוצרו תנאים חדשים (רשתות הכבישים ומשק החשמל), ונדרשה פרדיגמה אדריכלית המסכמת את רוח ההווה כחשיבה ארכיטקטונית; בטביעת המושגים משרת-משורת זיהה לואי קאהן כי עבור המודרניזם, חשיבותו של המתח שבין שני המושגים הללו גברה על זו של המתח הקלאסי. תפיסה זו מבקשת לסמן מחדש את מערכת היחסים האדריכליים.
					</p>
					<p class="main-text hidden" id="st-1">
						בשנות החמישים הציע מדען המחשב ג'ון פון ניומן פרדיגמה ארכיטקטונית לבניית מחשב. הפרדיגמה מתבססת על ארבעה רכיבים המתקשרים ביניהם - משתמש, יחידת בקרה, יחידה לוגית ושרת. המשתמש שולח בקשה לשרת, הבקשה עוברת תרגום על ידי יחידת הבקרה, היחידה הלוגית מתווכת אותה לשרת ומחזירה ערך מתורגם למשתמש. ארכיטקטורת פון ניומן מבוססת על רשת מעברים בין מטא-פרוגרמות שונות.
					</p>
					<p class="main-text hidden" id="st-2">
						בירושלים, הדרך למוזיאון ישראל אינה ישירה: כבישים, גשרים ושבילים יוצרים מערכת הכוונה וניתוב בתוך העיר. המרחק אינו מכשול אלא עיקרון-והגישה הופכת לניווט במערכת לוגית שמסוגלת לשמור, להסתיר ולכוון.
					</p>
					<p class="main-text hidden" id="st-3">
						בגבעת רם יישמנו את עקרונות ארכיטקטורת פון ניומן על תכנון פיזי: חילקנו את הקמפוס לקטגוריות של משתמש, בקרה, לוגיקה ושרת—ובהתאם לכך יצרנו מערך מרחבי חדש שבו כל פעולה מוצאת את מקומה במערכת כוללת. החלוקה המרחבית מניחה את השרתים, פרוגרמות הקצה שלא מהוות ציר תנועה, על גבי מערכת לוגית שמקשרת בין כלל האלמנטים. בהקבלה אליה ישנה יחידת בקרה שמתווכת את הכניסות ומסדרת את המרחב כולו.
					</p>
			</div>
		</div>
		
		<script>
			let wakeLock = null;

			async function requestWakeLock() {
				try {
					wakeLock = await navigator.wakeLock.request('screen');
					console.log('Wake Lock is active on ' + Date.now().toString());

					wakeLock.addEventListener('release', () => {
						console.log('Wake Lock was released on ' + Date.now().toString());
					});
				} catch (err) {
					console.error(`${err.name}, ${err.message}`);
				}
			}

			// Request the wake lock when the page is visible
			document.addEventListener('visibilitychange', () => {
				if (document.visibilityState === 'visible') {
					requestWakeLock();
				}
			});

			requestWakeLock();
		</script>
    </body>
</html>
